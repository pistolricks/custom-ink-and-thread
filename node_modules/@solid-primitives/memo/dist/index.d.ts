import { Accessor, Setter, AccessorArray, EffectFunction, MemoOptions, NoInfer, SignalOptions } from "solid-js";
import { EffectOptions } from "@solid-primitives/utils";
export type MemoOptionsWithValue<T> = MemoOptions<T> & {
    value?: T;
};
export type AsyncMemoCalculation<T, Init = undefined> = (prev: T | Init) => Promise<T> | T;
/**
 * Solid's `createReaction` that is based on pure computation *(runs before render, and is non-batching)*
 *
 * @param onInvalidate callback that runs when the tracked sources trigger update
 * @param options set computation name for debugging pourposes
 * - `options.initial` â€” an array of functions to be run initially and tracked. *(useful for runing code before other pure computations)*
 * @returns track() function
 *
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/memo#createPureReaction
 *
 * @example
 * const [count, setCount] = createSignal(0);
 * const track = createPureReaction(() => {...});
 * track(count);
 * setCount(1); // triggers callback
 *
 * // sources need to be re-tracked every time
 * setCount(2); // doesn't trigger callback
 */
export declare function createPureReaction(onInvalidate: VoidFunction, options?: EffectOptions): (tracking: VoidFunction) => void;
/**
 * A combined memo of multiple sources, last updated source will be the value of the returned signal.
 * @param sources list of reactive calculations/signals/memos
 * @param options signal options
 * @returns signal with value of the last updated source
 * @example
 * const [count, setCount] = createSignal(1);
 * const [text, setText] = createSignal("hello");
 * const lastUpdated = createLatest([count, text]);
 * lastUpdated() // => "hello"
 * setCount(4)
 * lastUpdated() // => 4
 */
export declare function createLatest<T extends readonly Accessor<any>[]>(sources: T, options?: MemoOptions<ReturnType<T[number]>>): Accessor<ReturnType<T[number]>>;
/**
 * A combined memo of multiple sources, returns the values of sources updated in the last tick.
 * @param sources list of reactive calculations/signals/memos
 * @param options signal options
 * @returns signal with value of the last updated sources
 * @example
 * const [count, setCount] = createSignal(1);
 * const [text, setText] = createSignal("hello");
 * const lastUpdated = createLatest([count, text]);
 * lastUpdated() // => [1, "hello"]
 * setCount(4)
 * lastUpdated() // => [4]
 */
export declare function createLatestMany<T extends readonly Accessor<any>[]>(sources: T, options?: EffectOptions): Accessor<ReturnType<T[number]>[]>;
/**
 * Solid's `createMemo` which value can be overwritten by a setter. Signal value will be the last one, set by a setter or a memo calculation.
 * @param fn callback that calculates the value
 * @param value initial value (for calcultion)
 * @param options give a name to the reactive computation, or change `equals` method.
 * @returns signal returning value of the last change.
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/memo#createWritableMemo
 * @example
 * const [count, setCount] = createSignal(1);
 * const [result, setResult] = createWritableMemo(() => count() * 2);
 * setResult(5) // overwrites calculation result
 */
export declare function createWritableMemo<Next extends Prev, Prev = Next>(fn: EffectFunction<undefined | NoInfer<Prev>, Next>): [signal: Accessor<Next>, setter: Setter<Next>];
export declare function createWritableMemo<Next extends Prev, Init = Next, Prev = Next>(fn: EffectFunction<Init | Prev, Next>, value: Init, options?: MemoOptions<Next>): [signal: Accessor<Next>, setter: Setter<Next>];
/**
 * @deprecated Please use `createSchedule` from `@solid-primitives/schedule` instead.
 */
export declare function createDebouncedMemo<Next extends Prev, Prev = Next>(fn: EffectFunction<undefined | NoInfer<Prev>, Next>, timeoutMs: number): Accessor<Next>;
export declare function createDebouncedMemo<Next extends Prev, Init = Next, Prev = Next>(fn: EffectFunction<Init | Prev, Next>, timeoutMs: number, value: Init, options?: MemoOptions<Next>): Accessor<Next>;
/**
 * @deprecated Please use `createSchedule` from `@solid-primitives/schedule` instead.
 */
export declare function createDebouncedMemoOn<S, Next extends Prev, Prev = Next>(deps: AccessorArray<S> | Accessor<S>, fn: (input: S, prevInput: S | undefined, prev: undefined | NoInfer<Prev>) => Next, timeoutMs: number): Accessor<Next>;
export declare function createDebouncedMemoOn<S, Next extends Prev, Init = Next, Prev = Next>(deps: AccessorArray<S> | Accessor<S>, fn: (input: S, prevInput: S | undefined, prev: Prev | Init) => Next, timeoutMs: number, value: Init, options?: MemoOptions<Next>): Accessor<Next>;
/**
 * @deprecated Please use `createSchedule` from `@solid-primitives/schedule` instead.
 */
export declare function createThrottledMemo<Next extends Prev, Prev = Next>(fn: EffectFunction<undefined | NoInfer<Prev>, Next>, timeoutMs: number): Accessor<Next>;
export declare function createThrottledMemo<Next extends Prev, Init = Next, Prev = Next>(fn: EffectFunction<Init | Prev, Next>, timeoutMs: number, value: Init, options?: MemoOptions<Next>): Accessor<Next>;
/**
 * @deprecated Please just use `createResource` instead.
 */
export declare function createAsyncMemo<T>(calc: AsyncMemoCalculation<T, T>, options: MemoOptionsWithValue<T> & {
    value: T;
}): Accessor<T>;
export declare function createAsyncMemo<T>(calc: AsyncMemoCalculation<T>, options?: MemoOptionsWithValue<T>): Accessor<T | undefined>;
/**
 * Lazily evaluated `createMemo`. Will run the calculation only if is being listened to.
 *
 * @param calc pure reactive calculation returning some value
 * @param value the initial previous value *(in callback)*
 * @param options set computation name for debugging pourposes
 * @returns signal of a value that was returned by the calculation
 *
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/memo#createLazyMemo
 *
 * @example
 * const double = createLazyMemo(() => count() * 2)
 */
export declare function createLazyMemo<T>(calc: (prev: T) => T, value: T, options?: EffectOptions): Accessor<T>;
export declare function createLazyMemo<T>(calc: (prev: T | undefined) => T, value?: undefined, options?: EffectOptions): Accessor<T>;
export type CacheCalculation<Key, Value> = (key: Key, prev: Value | undefined) => Value;
export type CacheKeyAccessor<Key, Value> = (key: Key) => Value;
export type CacheOptions<Value> = MemoOptions<Value> & {
    size?: number;
};
/**
 * Custom, lazily-evaluated, cached memo. The caching is based on a `key`, it has to be declared up-front as a reactive source, or passed to the signal access function.
 *
 * @param key a reactive source, that will serve as cache key (later value access for the same key will be taken from cache instead of recalculated)
 * @param calc calculation function returning value to cache. the function is **tracking** - will recalculate when the accessed signals change.
 * @param options set maximum **size** of the cache, or memo options.
 * @returns signal access function
 *
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/memo#createMemoCache
 *
 * @example
 * set the reactive key up-front
 * ```ts
 * const [count, setCount] = createSignal(1)
 * const double = createMemoCache(count, n => n * 2)
 * // access value:
 * double()
 * ```
 * or pass it to the access function (let's accessing different keys in different places)
 * ```ts
 * const double = createMemoCache((n: number) => n * 2)
 * // access with key
 * double(count())
 * ```
 */
export declare function createMemoCache<Key, Value>(key: Accessor<Key>, calc: CacheCalculation<Key, Value>, options?: CacheOptions<Value>): Accessor<Value>;
export declare function createMemoCache<Key, Value>(calc: CacheCalculation<Key, Value>, options?: CacheOptions<Value>): CacheKeyAccessor<Key, Value>;
/**
 * Primitive for updating signal in a predictable way. SolidJS equivalent of React's [useReducer](https://reactjs.org/docs/hooks-reference.html#usereducer).
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/memo#createReducer
 * @param dispatcher is the reducer, it's 1st parameter always is the current state of the reducer and it returns the new state of the reducer.
 * @param initialValue initial value of the signal
 * @returns
 * ```ts
 * [accessor: Accessor<State>, dispatch: (...args: ActionData) => void]
 * ```
 * - `accessor` can be used as you use a normal signal: `accessor()`. It contains the state of the reducer.
 * - `dispatch` is the action of the reducer, it is a sort of `setSignal` that does NOT receive the new state, but instructions to create it from the current state.
 */
export declare function createReducer<T, ActionData extends Array<any>>(dispatcher: (state: T, ...args: ActionData) => T, initialValue: T, options?: SignalOptions<T>): [accessor: Accessor<T>, dispatch: (...args: ActionData) => void];

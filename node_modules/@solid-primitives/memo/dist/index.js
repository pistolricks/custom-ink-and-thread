import { createSignal, createComputed, untrack, getOwner, onCleanup, createMemo, runWithOwner, on, createRoot, DEV, } from "solid-js";
import { isServer } from "solid-js/web";
import { debounce, throttle } from "@solid-primitives/scheduled";
import { noop, EQUALS_FALSE_OPTIONS } from "@solid-primitives/utils";
const callbackWith = (fn, v) => fn.length > 0 ? () => fn(untrack(v)) : fn;
/**
 * Solid's `createReaction` that is based on pure computation *(runs before render, and is non-batching)*
 *
 * @param onInvalidate callback that runs when the tracked sources trigger update
 * @param options set computation name for debugging pourposes
 * - `options.initial` â€” an array of functions to be run initially and tracked. *(useful for runing code before other pure computations)*
 * @returns track() function
 *
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/memo#createPureReaction
 *
 * @example
 * const [count, setCount] = createSignal(0);
 * const track = createPureReaction(() => {...});
 * track(count);
 * setCount(1); // triggers callback
 *
 * // sources need to be re-tracked every time
 * setCount(2); // doesn't trigger callback
 */
export function createPureReaction(onInvalidate, options) {
    if (isServer) {
        return () => void 0;
    }
    const owner = getOwner();
    const disposers = new Set();
    let trackers = 0;
    let disposed = false;
    onCleanup(() => {
        for (const fn of disposers)
            fn();
        disposers.clear();
        disposed = true;
    });
    // track()
    return tracking => {
        if (disposed) {
            untrack(tracking);
            return;
        }
        trackers++;
        createRoot(dispose => {
            disposers.add(dispose);
            let init = true;
            createComputed(() => {
                if (init) {
                    init = false;
                    return tracking();
                }
                if (--trackers === 0)
                    untrack(onInvalidate);
                dispose();
                disposers.delete(dispose);
            }, options);
        }, owner);
    };
}
/**
 * A combined memo of multiple sources, last updated source will be the value of the returned signal.
 * @param sources list of reactive calculations/signals/memos
 * @param options signal options
 * @returns signal with value of the last updated source
 * @example
 * const [count, setCount] = createSignal(1);
 * const [text, setText] = createSignal("hello");
 * const lastUpdated = createLatest([count, text]);
 * lastUpdated() // => "hello"
 * setCount(4)
 * lastUpdated() // => 4
 */
export function createLatest(sources, options) {
    let index = 0;
    const memos = sources.map((source, i) => createMemo(() => ((index = i), source()), undefined, DEV ? { name: i + 1 + ". source", equals: false } : EQUALS_FALSE_OPTIONS));
    return createMemo(() => memos.map(m => m())[index], undefined, options);
}
export function createLatestMany(sources, options) {
    const memos = sources.map((source, i) => {
        const obj = { dirty: true, get: null };
        obj.get = createMemo(() => ((obj.dirty = true), source()), undefined, DEV ? { name: i + 1 + ". source", equals: false } : EQUALS_FALSE_OPTIONS);
        return obj;
    });
    return createLazyMemo(() => memos.reduce((acc, memo) => {
        // always track all memos to force updates
        const v = memo.get();
        if (memo.dirty) {
            memo.dirty = false;
            acc.push(v);
        }
        return acc;
    }, []), undefined, options);
}
export function createWritableMemo(fn, value, options) {
    let combined = () => value;
    const [signal, setSignal] = createSignal(value, EQUALS_FALSE_OPTIONS), memo = createMemo(callbackWith(fn, () => combined()), value);
    return [
        (combined = createLatest([signal, memo], options)),
        ((setter) => setSignal(() => typeof setter === "function" ? setter(untrack(combined)) : setter)),
    ];
}
export function createDebouncedMemo(fn, timeoutMs, value, options) {
    const memo = createMemo(() => fn(value), undefined, options);
    if (isServer) {
        return memo;
    }
    const [signal, setSignal] = createSignal(untrack(memo));
    const updateSignal = debounce(() => (value = setSignal(memo)), timeoutMs);
    createComputed(on(memo, updateSignal, { defer: true }));
    return signal;
}
export function createDebouncedMemoOn(deps, fn, timeoutMs, value, options) {
    if (isServer) {
        return createMemo(on(deps, fn), value);
    }
    let init = true;
    const [signal, setSignal] = createSignal((() => {
        let v;
        createComputed(on(deps, (input, prevInput) => {
            if (init) {
                v = fn(input, prevInput, value);
                init = false;
            }
            else
                updateSignal(input, prevInput);
        }));
        return v;
    })(), options);
    const updateSignal = debounce((input, prevInput) => {
        setSignal(() => fn(input, prevInput, signal()));
    }, timeoutMs);
    return signal;
}
export function createThrottledMemo(fn, timeoutMs, value, options) {
    if (isServer) {
        return createMemo(fn);
    }
    let onInvalidate = noop;
    const track = createPureReaction(() => onInvalidate());
    const [state, setState] = createSignal((() => {
        let v;
        track(() => (v = fn(value)));
        return v;
    })(), options);
    onInvalidate = throttle(() => track(() => setState(fn)), timeoutMs);
    return state;
}
export function createAsyncMemo(calc, options = {}) {
    if (isServer) {
        return () => options.value;
    }
    const [state, setState] = createSignal(options.value, options);
    /** pending promises from oldest to newest */
    const order = [];
    // prettier-ignore
    createComputed(async () => {
        const value = calc(untrack(state));
        if (value instanceof Promise) {
            order.push(value);
            // resolved value will only be written to the signal,
            // if the promise wasn't removed from the array
            value.then(r => order.includes(value) && setState(() => r));
            // when a promise finishes, it removes itself, and every older promise from array,
            // blocking them from overwriting the state if they finish after
            value.finally(() => {
                const index = order.indexOf(value);
                order.splice(0, index + 1);
            });
        }
        else
            setState(() => value);
    }, undefined, options);
    return state;
}
export function createLazyMemo(calc, value, options) {
    if (isServer) {
        let calculated = false;
        return () => {
            if (!calculated) {
                calculated = true;
                value = calc(value);
            }
            return value;
        };
    }
    let isReading = false, isStale = true;
    const [track, trigger] = createSignal(void 0, EQUALS_FALSE_OPTIONS), memo = createMemo(p => (isReading ? calc(p) : ((isStale = !track()), p)), value, DEV ? { name: options?.name, equals: false } : EQUALS_FALSE_OPTIONS);
    return () => {
        isReading = true;
        if (isStale)
            isStale = trigger();
        const v = memo();
        isReading = false;
        return v;
    };
}
export function createMemoCache(...args) {
    const cache = new Map();
    const owner = getOwner();
    const key = typeof args[1] === "function" ? args[0] : undefined, calc = typeof args[1] === "function" ? args[1] : args[0], options = typeof args[1] === "object" ? args[1] : typeof args[2] === "object" ? args[2] : {};
    const run = key => {
        if (cache.has(key))
            return cache.get(key)();
        const memo = runWithOwner(owner, () => createLazyMemo(prev => calc(key, prev), undefined, options));
        if (options.size === undefined || cache.size < options.size)
            cache.set(key, memo);
        return memo();
    };
    return key ? () => run(key()) : run;
}
/**
 * Primitive for updating signal in a predictable way. SolidJS equivalent of React's [useReducer](https://reactjs.org/docs/hooks-reference.html#usereducer).
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/memo#createReducer
 * @param dispatcher is the reducer, it's 1st parameter always is the current state of the reducer and it returns the new state of the reducer.
 * @param initialValue initial value of the signal
 * @returns
 * ```ts
 * [accessor: Accessor<State>, dispatch: (...args: ActionData) => void]
 * ```
 * - `accessor` can be used as you use a normal signal: `accessor()`. It contains the state of the reducer.
 * - `dispatch` is the action of the reducer, it is a sort of `setSignal` that does NOT receive the new state, but instructions to create it from the current state.
 */
export function createReducer(dispatcher, initialValue, options) {
    const [state, setState] = createSignal(initialValue, options);
    return [state, (...args) => void setState(state => dispatcher(state, ...args))];
}

/**
 * adds a `.clear` method to a Storage without one only using `.key`/`.removeItem`
 */
export const addClearMethod = (storage) => {
    if (typeof storage.clear === "function") {
        return storage;
    }
    storage.clear = () => {
        let key;
        while ((key = storage.key(0))) {
            storage.removeItem(key);
        }
    };
    return storage;
};
const methodKeys = ["clear", "getItem", "getAll", "setItem", "removeItem", "key", "getLength"];
/**
 * adds a `.withOptions` method that wraps the storage to apply options
 */
export const addWithOptionsMethod = (storage) => {
    storage.withOptions = (options) => methodKeys.reduce((wrapped, key) => {
        if (typeof storage[key] === "function") {
            wrapped[key] = (...args) => {
                args[storage[key].length - 1] = options;
                return storage[key](...args);
            };
        }
        return wrapped;
    }, {
        get length() {
            return storage.length;
        },
        withOptions: (options) => storage.withOptions(options),
    });
    return storage;
};
const callStorageMethod = (storages, method, args = [], first = false) => {
    const results = storages.map(storage => storage[method](...args));
    const isAsync = results.some(result => typeof result === "object" && typeof result?.then === "function");
    return isAsync
        ? first
            ? Promise.race(results)
            : Promise.all(results)
        : first
            ? results.filter(Boolean)[0]
            : results;
};
const isNumber = (n) => typeof n === "number";
/**
 * combines multiple storages to a single storage
 */
export const multiplexStorage = (...storages) => ({
    clear: () => callStorageMethod(storages, "clear"),
    getItem: (key) => callStorageMethod(storages, "getItem", [key], true),
    setItem: (key, value) => callStorageMethod(storages, "setItem", [key, value]),
    removeItem: (key) => callStorageMethod(storages, "removeItem", [key]),
    key: (no) => callStorageMethod(storages, "key", [no], true),
    get length() {
        const lengths = storages.map(storage => storage.length);
        const isAsync = lengths.some(len => len && typeof len === "object" && typeof len.then === "function");
        return (isAsync
            ? Promise.all(lengths).then(lens => Math.max(...lens.filter(isNumber)))
            : Math.max(...lengths.filter(isNumber)));
    },
});
/**
 * Provides a minimal Storage API wrapper for an object
 */
export const makeObjectStorage = (object) => ({
    getItem: (key) => (Object.hasOwn(object, key) && object[key]) || null,
    setItem: (key, value) => {
        object[key] = value;
    },
    removeItem: (key) => {
        delete object[key];
    },
    key: (index) => Object.keys(object)[index],
    get length() {
        return Object.keys(object).length;
    },
    clear: () => Object.keys(object).forEach(key => {
        delete object[key];
    }),
});

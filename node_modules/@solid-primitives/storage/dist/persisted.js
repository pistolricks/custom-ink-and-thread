import { createUniqueId, untrack } from "solid-js";
import { isServer, isDev } from "solid-js/web";
import { reconcile } from "solid-js/store";
export function makePersisted(signal, options = {}) {
    const storage = options.storage || globalThis.localStorage;
    const name = options.name || `storage-${createUniqueId()}`;
    if (!storage) {
        return [signal[0], signal[1], null];
    }
    const storageOptions = options.storageOptions;
    const serialize = options.serialize || JSON.stringify.bind(JSON);
    const deserialize = options.deserialize || JSON.parse.bind(JSON);
    const init = storage.getItem(name, storageOptions);
    const set = typeof signal[0] === "function"
        ? (data) => {
            try {
                const value = deserialize(data);
                signal[1](() => value);
            }
            catch (e) {
                // eslint-disable-next-line no-console
                if (isDev)
                    console.warn(e);
            }
        }
        : (data) => {
            try {
                const value = deserialize(data);
                signal[1](reconcile(value));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                if (isDev)
                    console.warn(e);
            }
        };
    let unchanged = true;
    if (init instanceof Promise)
        init.then(data => unchanged && data && set(data));
    else if (init)
        set(init);
    if (typeof options.sync?.[0] === "function") {
        const get = typeof signal[0] === "function" ? signal[0] : () => signal[0];
        options.sync[0]((data) => {
            if (data.key !== name ||
                (!isServer && (data.url || globalThis.location.href) !== globalThis.location.href) ||
                data.newValue === serialize(untrack(get))) {
                return;
            }
            set(data.newValue);
        });
    }
    return [
        signal[0],
        typeof signal[0] === "function"
            ? (value) => {
                const output = signal[1](value);
                const serialized = value != null ? serialize(output) : value;
                options.sync?.[1](name, serialized);
                if (serialized != null)
                    storage.setItem(name, serialized, storageOptions);
                else
                    storage.removeItem(name, storageOptions);
                unchanged = false;
                return output;
            }
            : (...args) => {
                signal[1](...args);
                const value = serialize(untrack(() => signal[0]));
                options.sync?.[1](name, value);
                storage.setItem(name, value, storageOptions);
                unchanged = false;
            },
        init,
    ];
}
/**
 * storageSync - synchronize localStorage
 * This does only work for { storage: localStorage }.
 * If you wish to use e.g. cookieStorage, you may use a different sync method
 */
export const storageSync = [
    (subscriber) => window.addEventListener("storage", ev => subscriber(ev)),
    () => {
        /*storage already sends events fulfilling the PersistenceSyncData<T> conditions*/
    },
];
/**
 * messageSync - synchronize over post message or broadcast channel API
 */
export const messageSync = (channel = window) => [
    (subscriber) => channel.addEventListener("message", ev => {
        subscriber(ev.data);
    }),
    (key, newValue) => channel.postMessage({ key, newValue, timeStamp: +new Date(), url: location.href }, location.origin),
];
/**
 * wsSync - syncronize persisted storage via web socket
 */
export const wsSync = (ws, warnOnError = isDev) => [
    (subscriber) => ws.addEventListener("message", (ev) => {
        try {
            const data = JSON.parse(ev.data);
            if (["key", "newValue", "timeStamp"].every(item => Object.hasOwn(data, item))) {
                subscriber(data);
            }
        }
        catch (e) {
            // eslint-disable-next-line no-console
            if (warnOnError)
                console.warn(e);
        }
    }),
    (key, newValue) => ws.send(JSON.stringify({
        key,
        newValue,
        timeStamp: +new Date(),
        ...(isServer ? {} : { url: location.href }),
    })),
];
/**
 * multiplex arbitrary sync APIs
 *
 * ```ts
 * makePersisted(createSignal(0), { sync: multiplexSync(messageSync(bc), wsSync(ws)) })
 * ```
 */
export const multiplexSync = (...syncAPIs) => [
    subscriber => syncAPIs.forEach(([subscribe]) => subscribe(subscriber)),
    (key, value) => syncAPIs.forEach(([_, updater]) => updater(key, value)),
];

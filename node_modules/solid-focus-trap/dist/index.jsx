// src/focusTrap.ts
import { access } from "@corvu/utils/reactivity";
import {
  createEffect,
  createMemo,
  createSignal,
  mergeProps,
  onCleanup,
  untrack
} from "solid-js";
import { afterPaint } from "@corvu/utils/dom";
var focusableElementSelector = 'a[href]:not([tabindex="-1"]), button:not([tabindex="-1"]), input:not([tabindex="-1"]), textarea:not([tabindex="-1"]), select:not([tabindex="-1"]), details:not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])';
var EVENT_INITIAL_FOCUS = "focusTrap.initialFocus";
var EVENT_FINAL_FOCUS = "focusTrap.finalFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var createFocusTrap = (props) => {
  const defaultedProps = mergeProps(
    {
      enabled: true,
      observeChanges: true,
      restoreFocus: true
    },
    props
  );
  const [focusableElements, setFocusableElements] = createSignal(null);
  const firstFocusElement = createMemo(() => {
    const _focusableElements = focusableElements();
    if (!_focusableElements) return null;
    return _focusableElements[0] ?? null;
  });
  const lastFocusElement = createMemo(() => {
    const _focusableElements = focusableElements();
    if (!_focusableElements) return null;
    return _focusableElements[_focusableElements.length - 1] ?? null;
  });
  let originalFocusedElement = null;
  const mutationObserverCallback = () => {
    loadFocusTrap(access(defaultedProps.element));
    if (document.activeElement === null || document.activeElement === document.body) {
      initialFocus(access(defaultedProps.element));
    }
  };
  createEffect(() => {
    const container = access(defaultedProps.element);
    if (container && access(defaultedProps.enabled)) {
      originalFocusedElement = document.activeElement;
      untrack(() => {
        loadFocusTrap(container);
        initialFocus(container);
      });
      const observer = new MutationObserver(mutationObserverCallback);
      if (access(defaultedProps.observeChanges)) {
        observer.observe(container, {
          subtree: true,
          childList: true,
          attributes: true,
          attributeFilter: ["tabindex"]
        });
      }
      onCleanup(() => {
        if (access(defaultedProps.observeChanges)) {
          observer.disconnect();
        }
        setFocusableElements(null);
        restoreFocus(container);
      });
    }
  });
  createEffect(() => {
    const _focusableElements = focusableElements();
    if (_focusableElements === null || _focusableElements.length !== 0) return;
    document.addEventListener("keydown", preventFocusChange);
    onCleanup(() => {
      document.removeEventListener("keydown", preventFocusChange);
    });
  });
  createEffect(() => {
    const _firstFocusElement = firstFocusElement();
    if (!_firstFocusElement) return;
    _firstFocusElement.addEventListener("keydown", onFirstFocusElementKeyDown);
    onCleanup(() => {
      _firstFocusElement.removeEventListener(
        "keydown",
        onFirstFocusElementKeyDown
      );
    });
  });
  createEffect(() => {
    const _lastFocusElement = lastFocusElement();
    if (!_lastFocusElement) return;
    _lastFocusElement.addEventListener("keydown", onLastFocusElementKeyDown);
    onCleanup(() => {
      _lastFocusElement.removeEventListener(
        "keydown",
        onLastFocusElementKeyDown
      );
    });
  });
  const loadFocusTrap = (container) => {
    const focusableElements2 = Array.from(
      container.querySelectorAll(focusableElementSelector)
    ).map((element, domIndex) => ({
      element,
      domIndex,
      tabIndex: element.tabIndex
    })).sort((a, b) => {
      if (a.tabIndex === b.tabIndex) {
        return a.domIndex - b.domIndex;
      }
      return a.tabIndex - b.tabIndex;
    });
    setFocusableElements(focusableElements2.map(({ element }) => element));
  };
  const initialFocus = (container) => {
    afterPaint(() => {
      const initialFocusElement = access(defaultedProps.initialFocusElement) ?? firstFocusElement() ?? container;
      const onInitialFocus = defaultedProps.onInitialFocus;
      let event;
      if (onInitialFocus) {
        event = new CustomEvent(EVENT_INITIAL_FOCUS, EVENT_OPTIONS);
        container.addEventListener(EVENT_INITIAL_FOCUS, onInitialFocus);
        container.dispatchEvent(event);
        container.removeEventListener(EVENT_INITIAL_FOCUS, onInitialFocus);
      }
      if (event?.defaultPrevented === true) {
        return;
      }
      initialFocusElement.focus();
    });
  };
  const onFirstFocusElementKeyDown = (event) => {
    if (event.key === "Tab" && event.shiftKey) {
      event.preventDefault();
      lastFocusElement().focus();
    }
  };
  const onLastFocusElementKeyDown = (event) => {
    if (event.key === "Tab" && !event.shiftKey) {
      event.preventDefault();
      firstFocusElement().focus();
    }
  };
  const preventFocusChange = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
    }
  };
  const restoreFocus = (container) => {
    afterPaint(() => {
      const restoreFocus2 = access(defaultedProps.restoreFocus);
      if (!restoreFocus2) return;
      const finalFocusElement = access(defaultedProps.finalFocusElement) ?? originalFocusedElement;
      if (!finalFocusElement) {
        return;
      }
      let event;
      const onFinalFocus = defaultedProps.onFinalFocus;
      if (onFinalFocus) {
        event = new CustomEvent(EVENT_FINAL_FOCUS, EVENT_OPTIONS);
        container.addEventListener(EVENT_FINAL_FOCUS, onFinalFocus);
        container.dispatchEvent(event);
        container.removeEventListener(EVENT_FINAL_FOCUS, onFinalFocus);
      }
      if (event?.defaultPrevented === true) {
        return;
      }
      finalFocusElement.focus();
    });
  };
};
var focusTrap_default = createFocusTrap;

// src/index.ts
var index_default = focusTrap_default;
export {
  index_default as default
};

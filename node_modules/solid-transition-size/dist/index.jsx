// src/transitionSize.ts
import { access } from "@corvu/utils/reactivity";
import {
  batch,
  createEffect,
  createSignal,
  mergeProps,
  onCleanup
} from "solid-js";
import { afterPaint } from "@corvu/utils/dom";
function createTransitionSize(props) {
  const defaultedProps = mergeProps(
    {
      enabled: true,
      dimension: "both"
    },
    props
  );
  const [transitioning, setTransitioning] = createSignal(false);
  const [transitionSize, setTransitionSize] = createSignal(null);
  let startSize = null;
  createEffect(() => {
    const element = access(defaultedProps.element);
    const enabled = access(defaultedProps.enabled);
    if (!element || !enabled) return;
    const observer = new ResizeObserver(resizeObserverCallback);
    observer.observe(element);
    element.addEventListener("transitionend", reset);
    onCleanup(() => {
      observer.disconnect();
      element.removeEventListener("transitionend", reset);
      reset();
    });
  });
  const resizeObserverCallback = ([entry]) => {
    if (transitioning()) return;
    const target = entry.target;
    const currentSize = [
      target.offsetWidth,
      target.offsetHeight
    ];
    const dimension = access(defaultedProps.dimension);
    if (dimension === "both") {
      if (!startSize) {
        startSize = currentSize;
      } else if (startSize[0] !== currentSize[0] && startSize[1] !== currentSize[1]) {
        batch(() => {
          setTransitionSize(startSize);
          setTransitioning(true);
        });
        afterPaint(() => {
          setTransitionSize(currentSize);
          const transitionDuration = parseFloat(
            getComputedStyle(entry.target).transitionDuration
          );
          if (transitionDuration === 0) {
            reset();
          }
        });
      }
    } else {
      if (!startSize) {
        startSize = currentSize;
      } else if (getSizeOfDimension(dimension, startSize) !== getSizeOfDimension(dimension, currentSize)) {
        batch(() => {
          setTransitionSize(getSizeOfDimension(dimension, startSize));
          setTransitioning(true);
        });
        afterPaint(() => {
          setTransitionSize(getSizeOfDimension(dimension, currentSize));
          const transitionDuration = parseFloat(
            getComputedStyle(entry.target).transitionDuration
          );
          if (transitionDuration === 0) {
            reset();
          }
        });
      }
    }
  };
  const reset = () => {
    if (!transitioning()) return;
    const element = access(defaultedProps.element);
    if (element) {
      startSize = [element.offsetWidth, element.offsetHeight];
    } else {
      startSize = null;
    }
    batch(() => {
      setTransitioning(false);
      setTransitionSize(null);
    });
  };
  return {
    transitioning,
    transitionSize
  };
}
var getSizeOfDimension = (dimension, size) => {
  switch (dimension) {
    case "width":
      return size[0];
    case "height":
      return size[1];
  }
};
var transitionSize_default = createTransitionSize;

// src/index.ts
var src_default = transitionSize_default;
export {
  src_default as default
};

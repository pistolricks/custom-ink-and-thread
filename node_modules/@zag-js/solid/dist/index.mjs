import { mergeProps as mergeProps$1 } from '@zag-js/core';
import { createNormalizer } from '@zag-js/types';
import { onMount, onCleanup, createEffect } from 'solid-js';
import { createStore, reconcile } from 'solid-js/store';

// src/merge-props.ts
function mergeProps(...sources) {
  const target = {};
  for (let i = 0; i < sources.length; i++) {
    let source = sources[i];
    if (typeof source === "function") source = source();
    if (source) {
      const descriptors = Object.getOwnPropertyDescriptors(source);
      for (const key in descriptors) {
        if (key in target) continue;
        Object.defineProperty(target, key, {
          enumerable: true,
          get() {
            let e = {};
            if (key === "style" || key === "class" || key === "className" || key.startsWith("on")) {
              for (let i2 = 0; i2 < sources.length; i2++) {
                let s = sources[i2];
                if (typeof s === "function") s = s();
                e = mergeProps$1(e, { [key]: (s || {})[key] });
              }
              return e[key];
            }
            for (let i2 = sources.length - 1; i2 >= 0; i2--) {
              let v, s = sources[i2];
              if (typeof s === "function") s = s();
              v = (s || {})[key];
              if (v !== void 0) return v;
            }
          }
        });
      }
    }
  }
  return target;
}

// ../../utilities/core/src/guard.ts
var isArray = (v) => Array.isArray(v);
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject = (v) => isObjectLike(v) && !isArray(v);
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString = (v) => typeof v === "string";
var fnToString = Function.prototype.toString;
fnToString.call(Object);

// src/normalize-props.ts
var eventMap = {
  onFocus: "onFocusIn",
  onBlur: "onFocusOut",
  onDoubleClick: "onDblClick",
  onChange: "onInput",
  defaultChecked: "checked",
  defaultValue: "value",
  htmlFor: "for",
  className: "class"
};
var format = (v) => v.startsWith("--") ? v : hyphenateStyleName(v);
function toSolidProp(prop) {
  return prop in eventMap ? eventMap[prop] : prop;
}
var normalizeProps = createNormalizer((props) => {
  const normalized = {};
  for (const key in props) {
    const value = props[key];
    if (key === "readOnly" && value === false) {
      continue;
    }
    if (key === "style" && isObject(value)) {
      normalized["style"] = cssify(value);
      continue;
    }
    if (key === "children") {
      if (isString(value)) {
        normalized["textContent"] = value;
      }
      continue;
    }
    normalized[toSolidProp(key)] = value;
  }
  return normalized;
});
function cssify(style) {
  let css = {};
  for (const property in style) {
    const value = style[property];
    if (!isString(value) && !isNumber(value)) continue;
    css[format(property)] = value;
  }
  return css;
}
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
function toHyphenLower(match) {
  return "-" + match.toLowerCase();
}
var cache = {};
function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) return cache[name];
  var hName = name.replace(uppercasePattern, toHyphenLower);
  return cache[name] = msPattern.test(hName) ? "-" + hName : hName;
}
function useSnapshot(service, options) {
  const { actions, context } = options ?? {};
  const [state, setState] = createStore(service.getState());
  onMount(() => {
    const unsubscribe = service.subscribe((nextState) => {
      setState(reconcile(nextState));
    });
    onCleanup(() => {
      unsubscribe();
    });
  });
  createEffect(() => {
    const contextValue = typeof context === "function" ? context() : context;
    service.setContext(contextValue);
  });
  createEffect(() => {
    service.setOptions({ actions });
  });
  return state;
}

// src/use-actor.ts
function useActor(service) {
  const state = useSnapshot(service);
  return [state, service.send];
}
function useService(machine, options) {
  const { state: hydratedState, context } = options ?? {};
  const service = (() => {
    const instance = typeof machine === "function" ? machine() : machine;
    const ctx = typeof context === "function" ? context() : context;
    if (ctx) instance.setContext(ctx);
    instance._created();
    return instance;
  })();
  onMount(() => {
    service.start(hydratedState);
    onCleanup(() => {
      service.stop();
    });
  });
  return service;
}

// src/use-machine.ts
function useMachine(machine, options) {
  const service = useService(machine, options);
  const state = useSnapshot(service, options);
  return [state, service.send, service];
}

export { mergeProps, normalizeProps, useActor, useMachine };

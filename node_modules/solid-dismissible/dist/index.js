import { createComponent } from 'solid-js/web';
import { createContext, createSignal, mergeProps, createUniqueId, createMemo, useContext, splitProps, onCleanup, createEffect, untrack } from 'solid-js';
import { access } from '@corvu/utils/reactivity';
import createStyle from '@corvu/utils/create/style';
import { contains } from '@corvu/utils/dom';
import { isFunction } from '@corvu/utils';

// src/Dismissible.tsx
var createEscapeKeyDown = (props) => {
  const defaultedProps = mergeProps(
    {
      enabled: true
    },
    props
  );
  createEffect(() => {
    if (!access(defaultedProps.enabled)) {
      return;
    }
    document.addEventListener("keydown", handleKeyDown);
    onCleanup(() => {
      document.removeEventListener("keydown", handleKeyDown);
    });
  });
  const handleKeyDown = (event) => {
    if (event.key === "Escape") {
      defaultedProps.onEscapeKeyDown(event);
    }
  };
};
var escapeKeyDown_default = createEscapeKeyDown;
var createNoPointerEvents = (props) => {
  const defaultedProps = mergeProps(
    {
      enabled: true
    },
    props
  );
  createEffect(() => {
    const { body } = document;
    if (!access(defaultedProps.enabled)) return;
    createStyle({
      key: "no-pointer-events",
      element: body,
      style: {
        pointerEvents: "none"
      }
    });
  });
};
var noPointerEvents_default = createNoPointerEvents;
var EVENT_ON_FOCUS = "dismissible.outsideFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var createOutsideFocus = (props) => {
  const defaultedProps = mergeProps(
    {
      enabled: true,
      ignorePointerEvents: false
    },
    props
  );
  let pointerDown = false;
  createEffect(() => {
    if (!access(defaultedProps.enabled)) {
      return;
    }
    const ignorePointerEvents = access(defaultedProps.ignorePointerEvents);
    document.addEventListener("focusin", handleFocus);
    if (ignorePointerEvents) {
      document.addEventListener("pointerdown", handlePointerDown);
    }
    onCleanup(() => {
      document.removeEventListener("focusin", handleFocus);
      if (ignorePointerEvents) {
        document.removeEventListener("pointerdown", handlePointerDown);
      }
    });
  });
  const handleFocus = (event) => {
    if (pointerDown) {
      pointerDown = false;
      return;
    }
    const element = access(defaultedProps.element);
    if (element && !contains(element, event.target)) {
      const customEvent = new CustomEvent(EVENT_ON_FOCUS, EVENT_OPTIONS);
      element.dispatchEvent(customEvent);
      defaultedProps.onFocus(customEvent);
    }
  };
  const handlePointerDown = () => {
    pointerDown = true;
  };
};
var outsideFocus_default = createOutsideFocus;
var createOutsidePointer = (props) => {
  const defaultedProps = mergeProps(
    {
      enabled: true,
      strategy: "pointerup"
    },
    props
  );
  createEffect(() => {
    if (!access(defaultedProps.enabled)) {
      return;
    }
    const strategy = access(defaultedProps.strategy);
    document.addEventListener(strategy, handlePointer);
    onCleanup(() => {
      document.removeEventListener(strategy, handlePointer);
    });
  });
  const handlePointer = (event) => {
    const element = access(defaultedProps.element);
    const ignore = access(defaultedProps.ignore);
    if (element && !contains(element, event.target) && !(ignore && ignore.some(
      (ignoreElement) => ignoreElement && contains(ignoreElement, event.target)
    ))) {
      defaultedProps.onPointer(event);
    }
  };
};
var outsidePointer_default = createOutsidePointer;
var createDismissible = (props) => {
  const defaultedProps = mergeProps(
    {
      dismissOnEscapeKeyDown: true,
      dismissOnOutsideFocus: true,
      dismissOnOutsidePointer: true,
      outsidePointerStrategy: "pointerup",
      noOutsidePointerEvents: true
    },
    props
  );
  escapeKeyDown_default({
    enabled: () => access(defaultedProps.dismissOnEscapeKeyDown),
    onEscapeKeyDown: (event) => {
      defaultedProps.onEscapeKeyDown?.(event);
      if (!event.defaultPrevented) {
        defaultedProps.onDismiss("escapeKey");
      }
    }
  });
  outsideFocus_default({
    enabled: () => access(defaultedProps.dismissOnOutsideFocus),
    onFocus: (event) => {
      defaultedProps.onOutsideFocus?.(event);
      if (!event.defaultPrevented) {
        defaultedProps.onDismiss("outsideFocus");
      }
    },
    element: () => access(defaultedProps.element),
    ignorePointerEvents: () => access(defaultedProps.noOutsidePointerEvents) || access(defaultedProps.dismissOnOutsidePointer)
  });
  outsidePointer_default({
    enabled: () => access(defaultedProps.dismissOnOutsidePointer),
    strategy: () => access(defaultedProps.outsidePointerStrategy),
    ignore: () => access(defaultedProps.outsidePointerIgnore) ?? [],
    onPointer: (event) => {
      defaultedProps.onOutsidePointer?.(event);
      if (!event.defaultPrevented) {
        const ctrlLeftClick = event.button === 0 && event.ctrlKey === true;
        const isRightClick = event.button === 2 || ctrlLeftClick;
        if (isRightClick) return;
        defaultedProps.onDismiss("outsidePointer");
      }
    },
    element: () => access(defaultedProps.element)
  });
  noPointerEvents_default({
    enabled: () => access(defaultedProps.noOutsidePointerEvents)
  });
};
var dismissible_default = createDismissible;
var DismissibleContext = createContext();
var Dismissible = (props) => {
  const defaultedProps = mergeProps({
    dismissibleId: createUniqueId()
  }, props);
  const memoizedDismissible = createMemo(() => {
    const dismissibleContext = useContext(DismissibleContext);
    if (dismissibleContext) {
      return createComponent(DismissibleLayer, props);
    }
    const [layers, setLayers] = createSignal([defaultedProps.dismissibleId]);
    const onLayerShow = (dismissibleId) => {
      setLayers((layers2) => [...layers2, dismissibleId]);
    };
    const onLayerDismiss = (dismissibleId) => {
      setLayers((layers2) => layers2.filter((layer) => layer !== dismissibleId));
    };
    return createComponent(DismissibleContext.Provider, {
      value: {
        layers,
        onLayerShow,
        onLayerDismiss
      },
      get children() {
        return createComponent(DismissibleLayer, props);
      }
    });
  });
  return memoizedDismissible;
};
var [activeDismissibles, setActiveDismissibles] = createSignal([]);
var DismissibleLayer = (props) => {
  const defaultedProps = mergeProps({
    enabled: true,
    dismissibleId: createUniqueId(),
    dismissOnEscapeKeyDown: true,
    dismissOnOutsideFocus: true,
    dismissOnOutsidePointer: true,
    outsidePointerStrategy: "pointerup",
    noOutsidePointerEvents: true
  }, props);
  const [localProps, otherProps] = splitProps(defaultedProps, ["enabled", "children", "dismissOnEscapeKeyDown", "dismissOnOutsideFocus", "dismissOnOutsidePointer", "outsidePointerStrategy", "outsidePointerIgnore", "noOutsidePointerEvents", "onDismiss"]);
  const context = useContext(DismissibleContext);
  onCleanup(() => {
    context.onLayerDismiss(defaultedProps.dismissibleId);
    setActiveDismissibles((activeDismissibles2) => activeDismissibles2.filter((dismissibleId) => dismissibleId !== defaultedProps.dismissibleId));
  });
  createEffect(() => {
    if (localProps.enabled) {
      context.onLayerShow(defaultedProps.dismissibleId);
      setActiveDismissibles((activeDismissibles2) => [...activeDismissibles2, defaultedProps.dismissibleId]);
    } else {
      context.onLayerDismiss(defaultedProps.dismissibleId);
      setActiveDismissibles((activeDismissibles2) => activeDismissibles2.filter((dismissibleId) => dismissibleId !== defaultedProps.dismissibleId));
    }
  });
  const isLastLayer = () => {
    return context.layers()[context.layers().length - 1] === defaultedProps.dismissibleId;
  };
  dismissible_default({
    dismissOnEscapeKeyDown: () => access(localProps.dismissOnEscapeKeyDown) && isLastLayer() && localProps.enabled,
    dismissOnOutsideFocus: () => access(localProps.dismissOnOutsideFocus) && isLastLayer() && localProps.enabled,
    dismissOnOutsidePointer: () => access(localProps.dismissOnOutsidePointer) && isLastLayer() && localProps.enabled,
    outsidePointerStrategy: localProps.outsidePointerStrategy,
    outsidePointerIgnore: localProps.outsidePointerIgnore,
    noOutsidePointerEvents: () => access(localProps.noOutsidePointerEvents) && localProps.enabled,
    onDismiss: (reason) => {
      localProps.onDismiss(reason);
    },
    ...otherProps
  });
  const memoizedChildren = createMemo(() => localProps.children);
  const resolveChildren = () => {
    const children = memoizedChildren();
    if (isFunction(children)) {
      return children({
        get isLastLayer() {
          return isLastLayer();
        }
      });
    }
    return children;
  };
  return untrack(() => resolveChildren());
};
var Dismissible_default = Dismissible;

// src/index.ts
var src_default = Dismissible_default;

export { activeDismissibles, src_default as default };
